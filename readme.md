# Data Structures in Java (From Scratch)

This repository contains custom implementations of core **Data Structures in Java**, built from scratch to deeply understand how they work internally.

The project focuses on **engineering fundamentals**, not just academic implementations, with emphasis on:
- Time and space complexity analysis
- Design decisions and trade-offs
- Catching real implementation bugs using unit tests
- Writing clean, maintainable, interview-ready code

---

## ğŸ¯ Project Goals

- Implement data structures manually (no Java Collections)
- Understand *why* and *when* to use each data structure
- Practice clean architecture, testing, and documentation
- Build a strong foundation for backend and system design interviews

---

## ğŸ›  Tech Stack

- **Java**
- **Maven**
- **JUnit 5**

---

## ğŸ“š Implemented Data Structures

### âœ… Linear Data Structures
- Dynamic Array

Each data structure:
- Is implemented from scratch
- Uses Java generics
- Has dedicated unit tests
- Includes documented complexity and trade-offs

---

## â± Time & Space Complexity

For every data structure, the following aspects are analyzed and documented:
- Time complexity (best / average / worst cases)
- Space complexity
- Amortized analysis where applicable
- Common pitfalls and edge cases

---

## ğŸ§ª Testing Strategy

- All implementations are covered using **JUnit 5**
- Tests are written to validate:
    - Normal behavior
    - Edge cases
    - Boundary conditions
- Several bugs (such as off-by-one errors) were discovered and fixed through testing

Run all tests with:
```bash
mvn clean test
```
## ğŸ‘¤ Author

**Mahmoud El-Okaily**  
Backend Engineer & DevOps

ğŸ“ **Focus Areas**
- Backend Development
- Data Structures & Algorithms
- System Design
- Clean Architecture

ğŸ’¼ **Experience**
- 3+ years of backend development experience
- Hands-on work with Java, Node.js, and Laravel
- Strong focus on scalable and maintainable systems

ğŸ¯ **Engineering Philosophy**
- Strong fundamentals before abstractions
- Understanding the *why* behind every design decision
- Treating bugs as learning opportunities, not failures


